# In this file you can override any option defined in the reference files.
# Copy in parts of the reference files and modify as you please.

HOST = "localhost"
PORTS = {
  REMOTE_SELF_MONITOR = 3713
  REMOTE_REST_SERVICE = 4741
  KAIROS_DB = 8080
  H2_DB = 9093
  PRESENTER=8080
}
akka {

  # Loggers to register at boot time (akka.event.Logging$DefaultLogger logs
  # to STDOUT)
  loggers = ["akka.event.slf4j.Slf4jLogger"]

  # Log level used by the configured loggers (see "loggers") as soon
  # as they have been started; before that, see "stdout-loglevel"
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  loglevel = "DEBUG"

  # Log level for the very basic logger activated during ActorSystem startup.
  # This logger prints the log messages to stdout (System.out).
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  stdout-loglevel = "DEBUG"

  # Filter of log events that is used by the LoggingAdapter before
  # publishing log events to the eventStream.
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

  //  actor {
  //    provider = "cluster"
  //
  //    default-dispatcher {
  //      # Throughput for default Dispatcher, set to 1 for as fair as possible
  //      throughput = 10
  //    }
  //  }
  actor {
    provider = "akka.remote.RemoteActorRefProvider"
    warn-about-java-serializer-usage = false
  }
//  remote {
//    # The port clients should connect to. Default is 2552.
//    netty.tcp {
//      hostname = ${HOST}
//      port = 12345
//    }
//  }
}
configurations{
  numOfOC=20
  numOfAlarmPerOC=10000
  logPath="c:/temp"

  url="jdbc:h2:tcp://localhost/mem:test;DB_CLOSE_DELAY=-1;MULTI_THREADED=1;LOCK_MODE=3;LOG=0;UNDO_LOG=0"
  user="sa"
  pwd=""

  url_m="jdbc:mariadb://16.17.100.97:3306/test"
  user_m="root"
  pwd_m="root_123"

  maxRecord=50
  numOfTester=5

  tableName="temip_alarm"
  useSQL=true
  sql1="SELECT identifier,sourceIdentifier,event_time,alarmIdentifier,perceived_severity,operation_context,managed_object,alarm_type,additional_text,probable_cause,state,problem_status,sa_total,operator_note,acknowledgement_timestamp,acknowledgement_user_identifier,alarm_origin,clearance_report_flag,creation_timestamp,domain,escalatedAlarm,last_modification_timestamp,original_event_time,original_severity,previous_state,problemOccurrences,problem_information,specific_problems,target_entities,user_text,target,notificationIdentifier,outageFlag,correlGroup,termination_user_identifier,termination_timestamp,closedBy,releaseUserIdentifier,releaseTimestamp,closeUserIdentifier,closeTimestamp,handledUserIdentifier,handleTimestamp,clearanceTimeStamp,uniqueid FROM temip_alarm WHERE (state = 'Outstanding') order by event_time desc  LIMIT 0 , 500"
  sql2="SELECT identifier,sourceIdentifier,event_time,alarmIdentifier,perceived_severity,operation_context,managed_object,alarm_type,additional_text,probable_cause,state,problem_status,sa_total,operator_note,acknowledgement_timestamp,acknowledgement_user_identifier,alarm_origin,clearance_report_flag,creation_timestamp,domain,escalatedAlarm,last_modification_timestamp,original_event_time,original_severity,previous_state,problemOccurrences,problem_information,specific_problems,target_entities,user_text,target,notificationIdentifier,outageFlag,correlGroup,termination_user_identifier,termination_timestamp,closedBy,releaseUserIdentifier,releaseTimestamp,closeUserIdentifier,closeTimestamp,handledUserIdentifier,handleTimestamp,clearanceTimeStamp,uniqueid FROM temip_alarm WHERE  state='Outstanding' and problem_status='Handled' and operation_context='perf_oc1'  order by event_time desc LIMIT 0 , 500"
  sqlg="SELECT  COALESCE(COUNT(identifier), 0) count_identifier,perceived_severity perceived_severity FROM  ( SELECT identifier,perceived_severity FROM temip_alarm) tmp  GROUP BY perceived_severity LIMIT 0 , 100000"
  sql="SELECT  COALESCE(COUNT(identifier), 0) count_identifier,perceived_severity perceived_severity ,operation_context FROM  ( SELECT identifier,perceived_severity, operation_context FROM temip_alarm) tmp  GROUP BY perceived_severity,operation_context  LIMIT 0 , 100000"
}
